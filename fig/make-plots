#!/usr/bin/env python3

import argparse
import subprocess
import tempfile

import numpy as np
import h5py
import husl
import george
import mtd
import matplotlib.pyplot as plt
from matplotlib import ticker
from matplotlib.colors import LinearSegmentedColormap


fontsmall, fontnormal, fontlarge = 5, 6, 7
offblack = '#262626'
aspect = 1/1.618
resolution = 72.27
textwidth = 307.28987/resolution
textheight = 261.39864/resolution
fullwidth = 350/resolution
fullheight = 270/resolution

plt.rcdefaults()
plt.rcParams.update({
    'font.family': 'sans-serif',
    'font.sans-serif': ['Lato'],
    'mathtext.fontset': 'custom',
    'mathtext.default': 'it',
    'mathtext.rm': 'sans',
    'mathtext.it': 'sans:italic:medium',
    'mathtext.cal': 'sans',
    'font.size': fontnormal,
    'legend.fontsize': fontnormal,
    'axes.labelsize': fontnormal,
    'axes.titlesize': fontlarge,
    'xtick.labelsize': fontsmall,
    'ytick.labelsize': fontsmall,
    'font.weight': 400,
    'axes.labelweight': 400,
    'axes.titleweight': 400,
    'lines.linewidth': .7,
    'lines.markersize': 3,
    'lines.markeredgewidth': 0,
    'patch.linewidth': .7,
    'axes.linewidth': .4,
    'xtick.major.width': .4,
    'ytick.major.width': .4,
    'xtick.minor.width': .4,
    'ytick.minor.width': .4,
    'xtick.major.size': 1.2,
    'ytick.major.size': 1.2,
    'xtick.minor.size': .8,
    'ytick.minor.size': .8,
    'xtick.major.pad': 1.5,
    'ytick.major.pad': 1.5,
    'axes.labelpad': 3,
    'text.color': offblack,
    'axes.edgecolor': offblack,
    'axes.labelcolor': offblack,
    'xtick.color': offblack,
    'ytick.color': offblack,
    'legend.numpoints': 1,
    'legend.scatterpoints': 1,
    'legend.frameon': False,
    'image.interpolation': 'none',
    'pdf.fonttype': 42
})


plot_functions = {}


def plot(f):
    def wrapper(*args, **kwargs):
        print(f.__name__)
        f(*args, **kwargs)
        plt.savefig('{}.pdf'.format(f.__name__))
        plt.close()

    plot_functions[f.__name__] = wrapper

    return wrapper


def finish(
        despine=True, remove_ticks=False,
        pad=0.1, h_pad=None, w_pad=None,
        rect=None
):
    fig = plt.gcf()

    for ax in fig.axes:
        if despine:
            for spine in 'top', 'right':
                ax.spines[spine].set_visible(False)

        if remove_ticks:
            for ax_name in 'xaxis', 'yaxis':
                getattr(ax, ax_name).set_ticks_position('none')
        else:
            ax.xaxis.set_ticks_position('bottom')
            ax.yaxis.set_ticks_position('left')

    fig.tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad, rect=rect)


def set_loc(ax, xy=None, nbins=5, steps=[1, 2, 3, 4, 10],
            prune=None, minor=0):
    if xy == 'x':
        axes = ax.xaxis,
    elif xy == 'y':
        axes = ax.yaxis,
    else:
        axes = ax.xaxis, ax.yaxis

    for axis in axes:
        axis.set_major_locator(
            ticker.MaxNLocator(nbins=nbins, steps=steps, prune=prune)
        )
        if minor:
            axis.set_minor_locator(ticker.AutoMinorLocator(minor))


def credible_interval(samples, ci=.9):
    """
    Compute the HPD credible interval (default 90%) for an array of samples.
    The array will be sorted in place.

    """
    samples.sort()

    # number of intervals to compute
    nci = int((1 - ci)*samples.size)

    # find highest posterior density (HPD) credible interval
    # i.e. the one with minimum width
    cil = samples[:nci]   # interval lows
    cih = samples[-nci:]  # interval highs
    ihpd = np.argmin(cih - cil)

    return cil[ihpd], cih[ihpd]


def format_ci(samples, ci=.9):
    """
    Compute the median and a credible interval (default 90%) for an array of
    samples and return a TeX-formatted string.
    The array will be sorted in place.

    """
    cil, cih = credible_interval(samples, ci=ci)
    median = samples[int(.5*samples.size)]
    ul = median - cil
    uh = cih - median

    # decide precision for formatting numbers
    # this is NOT general but it works for the present data
    if abs(median) < .2 and ul < .02:
        precision = 3
    elif abs(median) < 1:
        precision = 2
    elif abs(median) > 10:
        precision = 0
    else:
        precision = 1

    fmt = str(precision).join(['{:#.', 'f}'])

    return ''.join([
        '$', fmt.format(median),
        '_{-', fmt.format(ul), '}',
        '^{+', fmt.format(uh), '}$'
    ])


_chains = {}


def load_chain(filename):
    """
    Read and cache an MCMC calibration chain.

    """
    if filename not in _chains:
        with h5py.File(filename, 'r') as f:
            _chains[filename] = np.array(f['chain'])

    return _chains[filename]


def _posterior(design, calibration, calibration_nch, upper=False):
    with h5py.File(design, 'r') as f:
        labels = list(f['labels'])
        etas_hrg_index = 4
        indices = np.arange(len(labels)) != etas_hrg_index
        del labels[etas_hrg_index]
        ranges = np.array(f['range'])[indices]
        # override upper limit for norm
        ranges[0, 1] = 160

    chain = load_chain(calibration).T[indices]
    chain2 = load_chain(calibration_nch).T[indices]
    # with h5py.File(calibration, 'r') as f:
    #     chain = np.array(f['chain']).T[indices]

    nxy = chain.shape[0]
    assert nxy == len(labels)

    def recolor(rgb):
        h, s, l = husl.rgb_to_husl(*rgb)
        return husl.husl_to_rgb(h, .75*s, min(1.02*l, 100))

    normal_cmap = plt.cm.Blues
    highlight_cmap = plt.cm.Oranges
    alt_cmap = LinearSegmentedColormap.from_list(
        'Reds_mod',
        [recolor(rgba[:3]) for rgba in plt.cm.Reds(np.linspace(0, 1, 9))]
    )

    fig, axes = plt.subplots(
        nrows=nxy, ncols=nxy,
        sharex='col', sharey='row',
        figsize=(fullheight, fullheight)
    )

    Tswitch_index = 7

    for n, (ax, c, c2, lim) in enumerate(
            zip(axes.diagonal(), chain, chain2, ranges)
    ):
        (counts, edges), (counts2, _) = [
            np.histogram(c_, bins=100, range=lim, density=True)
            for c_ in [c, c2]
        ]
        x = (edges[1:] + edges[:-1]) / 2
        counts_max = max(counts.max(), counts2.max())

        def plot_hist(counts_, cmap):
            y = .84 * (lim[1] - lim[0]) * counts_ / counts_max + lim[0]
            ax.plot(x, y, color=cmap(.8), lw=.6)
            ax.fill_between(x, lim[0], y, color=cmap(.1), zorder=-10)

        plot_hist(
            counts,
            highlight_cmap if not upper and n in [1, 6, 7] else normal_cmap
        )
        if upper:
            plot_hist(counts2, alt_cmap)
        else:
            ax.annotate(
                format_ci(c.copy()), (.2, .95), xycoords='axes fraction',
                ha='left', va='bottom'
            )

        ax.set_xlim(lim)
        ax.set_ylim(lim)

        ticks = [lim[0], (lim[0] + lim[1])/2, lim[1]]
        if n == Tswitch_index:
            ticks[0] = .14
            ticks[2] = .16
        ax.set_xticks(ticks)
        ax.set_yticks(ticks)

    for ny, nx in zip(*np.tril_indices_from(axes, k=-1)):
        def plot_hist(chain_, nx_, ny_, cmap):
            H, xedges, yedges = np.histogram2d(
                chain_[nx_], chain_[ny_], bins=100,
                range=(ranges[nx_], ranges[ny_])
            )
            H[H == 0] = None
            axes[ny_][nx_].pcolorfast(xedges, yedges, H.T, cmap=cmap)

        plot_hist(
            chain, nx, ny,
            highlight_cmap if not upper and (ny, nx) == (5, 4) else normal_cmap
        )

        if upper:
            plot_hist(chain2, ny, nx, alt_cmap)
        else:
            axes[nx][ny].set_axis_off()

    for n, label in enumerate(labels):
        for ax, xy in [(axes[-1, n], 'x'), (axes[n, 0], 'y')]:
            getattr(ax, 'set_{}label'.format(xy))(label)
            ticklabels = getattr(ax, 'get_{}ticklabels'.format(xy))()
            for t in ticklabels:
                t.set_fontsize(4)
            if n == Tswitch_index:
                continue
            if xy == 'x':
                ticklabels[0].set_horizontalalignment('left')
                ticklabels[-1].set_horizontalalignment('right')
            else:
                ticklabels[0].set_verticalalignment('bottom')
                ticklabels[-1].set_verticalalignment('top')

        if upper:
            axes[0, n].annotate(
                label, xy=(0.5, 1.02), xycoords='axes fraction',
                va='bottom', ha='center'
            )
            axes[n, -1].annotate(
                label, xy=(1.04, 0.5), xycoords='axes fraction',
                va='center', ha='left', rotation=-90
            )

    finish(pad=0, rect=[0., 0., .97, .97])


@plot
def posterior_lower(design, calibration, calibration_nch, **kwargs):
    _posterior(design, calibration, calibration_nch, upper=False)


@plot
def posterior_pair(design, calibration, calibration_nch, **kwargs):
    _posterior(design, calibration, calibration_nch, upper=True)


def _observables_plot(model_data, exp_data, posterior=False):
    id_parts = [
        ('pion',   r'$\pi^\pm$', 'Blues'),
        ('kaon',   r'$K^\pm$', 'Greens'),
        ('proton', r'$p\bar p$', 'Reds')
    ]

    flows = [(str(n), '$v_{}$'.format(n), c)
             for n, c in enumerate(['GnBu', 'Purples', 'Oranges'], start=2)]

    plots = [
        ('dN_dy', 'Identified particle yields', r'$dN/dy$', (1, 4e3),
         id_parts),
        ('mean_pT', 'Identified particle mean $p_T$',
         r'$p_T$ [GeV]', (0, 1.8), id_parts),
        ('vn', 'Flow cumulants', r'$v_n\{2\}$', (0, 0.12), flows),
    ]

    fig, axes = plt.subplots(
        ncols=2, nrows=2,
        figsize=(fullwidth, aspect*fullwidth)
    )

    axes[0][0].set_axis_off()

    with \
            h5py.File(model_data, 'r') as model, \
            h5py.File(exp_data, 'r') as exp:
        if posterior:
            samples = np.random.randint(0, model['chain'].shape[0], size=100)

        for ax, (obs, title, ylabel, ylim, subplots) in zip(
                axes.flat[1:], plots
        ):
            for subobs, label, cmap in subplots:
                color = getattr(plt.cm, cmap)(0.6)

                n = 6 if obs == 'vn' and subobs != '2' else 8

                x, y, yerr = (exp[obs][subobs][k][:n]
                              for k in ['x', 'y', 'yerr'])

                ax.errorbar(x, y, yerr=yerr, fmt='o', ms=2.5,
                            capsize=0, color='0.2', zorder=1000)

                ax.text(x[-1] + 2, y[-1], label, ha='left', va='center',
                        size=fontnormal)

                kwargs = dict(color=color, alpha=0.2, lw=0.3)

                if posterior:
                    for i in samples:
                        ax.plot(x, model['samples'][obs][subobs][i], **kwargs)
                else:
                    for y in model[obs][subobs]['Y'][:, :n]:
                        ax.plot(x, y, **kwargs)

            ax.set_xlim(0, 70)
            ax.set_ylim(ylim)
            ax.set_ylabel(ylabel)
            ax.set_title(title)

            if obs == 'dN_dy':
                ax.set_yscale('log')
                ax.minorticks_off()
            else:
                set_loc(ax, 'y', nbins=6)

    for ax in axes.flat:
        ax.set_xlabel('Centrality %')

    finish(w_pad=1, h_pad=1)


@plot
def observables_prior(batch_obs, exp_data, **kwargs):
    _observables_plot(batch_obs, exp_data, posterior=False)


@plot
def observables_posterior(calibration, exp_data, **kwargs):
    _observables_plot(calibration, exp_data, posterior=True)


@plot
def etas_estimate(calibration, **kwargs):
    plt.figure(figsize=(.7*textwidth, .7*aspect*textwidth))
    ax = plt.axes()

    T = np.linspace(.154, .3, 50)
    dT = T - T[0]

    prior = ax.fill_between(T, .3 + 2*dT, color='.92')

    etas_min, etas_slope = load_chain(calibration).T[5:7]
    # with h5py.File(calibration, 'r') as f:
    #     etas_min, etas_slope = f['chain'][:, 5:7].T

    intervals = np.array([
        credible_interval(etas_min + dT_*etas_slope)
        for dT_ in dT
    ]).T

    band = ax.fill_between(T, *intervals, color=plt.cm.Blues(.32))

    ax.plot(T, np.full_like(T, 1/(4*np.pi)), color='.6')
    ax.text(.299, .07, r'KSS bound $1/4\pi$', va='top', ha='right', color='.4')

    median, = ax.plot(
        T, np.median(etas_min) + dT*np.median(etas_slope),
        color=plt.cm.Blues(.77)
    )

    ax.set_xlim(xmin=.146)
    ax.set_xticks(np.arange(150, 301, 50)/1000)
    ax.xaxis.set_minor_locator(ticker.AutoMinorLocator(2))
    set_loc(ax, 'y', minor=2)

    ax.set_xlabel('Temperature [GeV]')
    ax.set_ylabel(r'$\eta/s$')

    ax.legend(*zip(*[
        (prior, 'Prior range'),
        (median, 'Posterior median'),
        (band, '90% CR'),
    ]), loc='upper left')

    finish()


def _mode_observables(batch_obs_mode, batch_obs_mode_nch, exp_data, nch=False):
    id_parts = [
        ('pion',   r'$\pi^\pm$', 'Blues'),
        ('kaon',   r'$K^\pm$', 'Greens'),
        ('proton', r'$p\bar p$', 'Reds')
    ]

    flows = [(str(n), '$v_{}$'.format(n), c)
             for n, c in enumerate(['GnBu', 'Purples', 'Oranges'], start=2)]

    nch_factor = 5

    plots = [
        ('dN_dy', 'Yields',
         r'$dN/dy$, $dN_\mathrm{ch}/d\eta \times ' + str(nch_factor) + '$',
         (1, 1e4),
         id_parts + [(None, r'$N_\mathrm{ch}$', 'Greys')]),
        ('mean_pT', 'Identified particle mean $p_T$',
         r'$p_T$ [GeV]', (0, 1.5), id_parts),
        ('vn', 'Flow cumulants', r'$v_n\{2\}$', (0, 0.11), flows),
    ]

    fig = plt.figure(figsize=(fullwidth, .75*aspect*textwidth))
    gs = plt.GridSpec(3, len(plots))

    with \
            h5py.File(batch_obs_mode, 'r') as mode, \
            h5py.File(batch_obs_mode_nch, 'r') as mode_nch, \
            h5py.File(exp_data, 'r') as exp:
        if nch:
            modes_alphas = [(mode, .4), (mode_nch, 1)]
        else:
            modes_alphas = [(mode, 1)]

        for n, (obs, title, ylabel, ylim, subplots) in enumerate(plots):
            ax = fig.add_subplot(gs[:2, n])
            ratio_ax = fig.add_subplot(gs[2, n])

            for subobs, label, cmap in subplots:
                if obs == 'dN_dy' and subobs is None:
                    obs_key = 'dNch_deta'
                    factor = nch_factor
                else:
                    obs_key = '/'.join([obs, subobs])
                    factor = 1

                color = getattr(plt.cm, cmap)(0.7)
                ncent = min(i[obs_key]['x'].size for i in [mode, exp])

                x = mode[obs_key]['x'][:ncent]

                yexp, yexperr = (exp[obs_key][k][:ncent]
                                 for k in ['y', 'yerr'])
                yexp *= factor
                yexperr *= factor

                for m, a in modes_alphas:
                    y = m[obs_key]['Y'][0, :ncent]
                    y *= factor
                    ax.plot(x, y, color=color, alpha=a)
                    ratio_ax.plot(x, y/yexp, color=color, alpha=a)

                ax.errorbar(
                    x, yexp, yerr=yexperr,
                    fmt='o', ms=2.5, capsize=0, color='0.2',
                    zorder=1000
                )

                ax.text(x[-1] + 3, y[-1], label, ha='left', va='center',
                        size=fontnormal)

            ax.set_ylim(ylim)
            ax.set_ylabel(ylabel)
            ax.set_title(title)

            if obs == 'dN_dy':
                ax.set_yscale('log')
                ax.minorticks_off()
            else:
                set_loc(ax, 'y', nbins=6)

            ratio_ax.axhline(1, lw=.5, color='0.5', zorder=-100)
            ratio_ax.axhspan(0.9, 1.1, color='0.95', zorder=-200)

            ratio_ax.set_xlabel('Centrality %')
            ratio_ax.set_ylim(0.8, 1.2)
            ratio_ax.set_yticks(np.arange(80, 121, 10)/100)
            ratio_ax.set_ylabel('Ratio')

    finish(pad=.1, h_pad=.5, w_pad=.5)


@plot
def mode_observables_id(batch_obs_mode, batch_obs_mode_nch, exp_data, **kw):
    _mode_observables(batch_obs_mode, batch_obs_mode_nch, exp_data, nch=False)


@plot
def mode_observables_both(batch_obs_mode, batch_obs_mode_nch, exp_data, **kw):
    _mode_observables(batch_obs_mode, batch_obs_mode_nch, exp_data, nch=True)


@plot
def design(design, **kwargs):
    fig = plt.figure(figsize=(.5*textwidth, .5*textwidth))
    ratio = 5
    gs = plt.GridSpec(ratio + 1, ratio + 1)

    ax_j = fig.add_subplot(gs[1:, :-1])
    ax_x = fig.add_subplot(gs[0, :-1], sharex=ax_j)
    ax_y = fig.add_subplot(gs[1:, -1], sharey=ax_j)

    with h5py.File(design, 'r') as f:
        i, j = 5, 6
        x = f['design/main'][:, i]
        y = f['design/main'][:, j]
        xlabel = f['labels'][i]
        ylabel = f['labels'][j]
        xlim = f['range'][i, :]
        ylim = f['range'][j, :]

    ax_j.plot(x, y, 'o', color=plt.cm.Blues(0.75), mec='white', mew=.3)

    hist_kw = dict(bins=30, color=plt.cm.Blues(0.4), edgecolor='white', lw=.5)
    ax_x.hist(x, **hist_kw)
    ax_y.hist(y, orientation='horizontal', **hist_kw)

    for ax in fig.axes:
        ax.tick_params(top='off', right='off')
        spines = ['top', 'right']
        if ax is ax_x:
            spines += ['left']
        elif ax is ax_y:
            spines += ['bottom']
        for spine in spines:
            ax.spines[spine].set_visible(False)
        for ax_name in 'xaxis', 'yaxis':
            getattr(ax, ax_name).set_ticks_position('none')

    for ax in ax_x, ax_y:
        ax.tick_params(labelbottom='off', labelleft='off')

    ax_j.set_xlim(xlim)
    ax_j.set_ylim(ylim)
    set_loc(ax_j, nbins=4, steps=[1, 2, 3, 4, 5, 10])

    ax_j.set_xlabel(xlabel)
    ax_j.set_ylabel(ylabel)

    gs.tight_layout(fig=fig, pad=0.)


@plot
def pca(batch_obs, **kwargs):
    fig = plt.figure(figsize=(.5*textwidth, .5*textwidth))
    ratio = 5
    gs = plt.GridSpec(ratio + 1, ratio + 1)

    ax_j = fig.add_subplot(gs[1:, :-1])
    ax_x = fig.add_subplot(gs[0, :-1], sharex=ax_j)
    ax_y = fig.add_subplot(gs[1:, -1], sharey=ax_j)

    with h5py.File(batch_obs, 'r') as f:
        i = 3
        x = f['dN_dy/pion/Y'][:, i]
        y = f['vn/2/Y'][:, i]
        xlabel = r'$dN_{\pi^\pm}/dy$'
        ylabel = r'$v_2\{2\}$'
        xlim = 0, 2000
        ylim = 0, 0.12

    ax_j.plot(x, y, 'o', color=plt.cm.Blues(0.75), mec='white', mew=.25,
              zorder=10)

    hist_kw = dict(bins=16, color=plt.cm.Blues(0.4), edgecolor='white')
    ax_x.hist(x, **hist_kw)
    ax_y.hist(y, orientation='horizontal', **hist_kw)

    xy = np.column_stack((x, y))
    xymean = xy.mean(axis=0)
    xystd = xy.std(axis=0)
    xy -= xymean
    xy /= xystd
    pca = mtd.PCA(xy)
    pc = 5.5 * xystd * pca.weights[:, np.newaxis] * pca.pc

    for w, p in zip(pca.weights, pc):
        if np.all(p < 0):
            p *= -1
        ax_j.annotate('', xymean + p, xymean,
                      zorder=20, arrowprops=dict(
                          arrowstyle='->', shrinkA=0, shrinkB=0,
                          color=offblack, lw=.7
                      ))
        ax_j.text(*(xymean + p + (.8, .002)*np.sign(p)),
                  s='{:.0f}%'.format(100*w), color=offblack,
                  fontsize=fontlarge,
                  ha='center', va='top' if p[1] < 0 else 'bottom',
                  zorder=20)

    for ax in fig.axes:
        ax.tick_params(top='off', right='off')
        spines = ['top', 'right']
        if ax is ax_x:
            spines += ['left']
        elif ax is ax_y:
            spines += ['bottom']
        for spine in spines:
            ax.spines[spine].set_visible(False)
        for ax_name in 'xaxis', 'yaxis':
            getattr(ax, ax_name).set_ticks_position('none')

    for ax in ax_x, ax_y:
        ax.tick_params(labelbottom='off', labelleft='off')

    ax_j.set_xlim(xlim)
    ax_j.set_ylim(ylim)
    set_loc(ax_j, nbins=4, steps=[1, 2, 3, 4, 5, 10])

    ax_j.set_xlabel(xlabel)
    ax_j.set_ylabel(ylabel)

    ax_j.annotate('20–30%', (.03, .03), xycoords='axes fraction',
                  ha='left', va='bottom', fontsize=fontlarge)

    gs.tight_layout(fig=fig, pad=0.)


@plot
def pca_variance(batch_obs, exp_data, **kwargs):
    observables = [
        ('dN_dy/pion',     8),
        ('dN_dy/kaon',     8),
        ('dN_dy/proton',   8),
        ('mean_pT/pion',   8),
        ('mean_pT/kaon',   8),
        ('mean_pT/proton', 8),
        ('vn/2',           8),
        ('vn/3',           6),
        ('vn/4',           6),
    ]

    with h5py.File(batch_obs, 'r') as f:
        model = np.hstack([f[k]['Y'][:, :n] for k, n in observables])

    with h5py.File(exp_data, 'r') as f:
        exp = np.hstack([f[k]['y'][:n] for k, n in observables])

    pca = mtd.PCA(model/exp)
    npc = 8

    fig = plt.figure(figsize=(.5*textwidth, .5*aspect*textwidth))
    ax = fig.gca()

    ax.plot(np.arange(npc) + 1, pca.weights[:npc].cumsum(), '-o',
            mfc=plt.cm.Blues(0.75), ms=4, mew=.4, mec='white',
            color=plt.cm.Blues(0.5))
    ax.axhline(1, color='0.7', zorder=-10)

    ax.set_xlim(0.75, npc + 0.25)
    ax.set_ylim(0.7, 1.01)

    ax.set_yticks(np.arange(7, 11)/10)

    ax.set_xlabel('Number of PC')
    ax.set_ylabel('Explained variance')

    finish(remove_ticks=True)


@plot
def validation(calibration, batch_obs_validation, **kwargs):
    observables = [
        ('dN_dy/pion', r'$dN_{\pi^\pm}/dy$', (0, 3200)),
        ('mean_pT/pion', r'$\langle p_T \rangle_{\pi^\pm}$', (0.4, 0.75)),
        ('vn/2', r'$v_2\{2\}$', (0, 0.13)),
    ]

    cent_edges = [0, 5, 10, 20, 30, 40, 50, 60, 70, 80]
    cent_bins = list(zip(cent_edges[:-1], cent_edges[1:]))

    fig, axes = plt.subplots(
        ncols=len(observables),
        figsize=(textwidth, 1.1/3*textwidth)
    )

    with \
            h5py.File(calibration, 'r') as cal, \
            h5py.File(batch_obs_validation, 'r') as vld:
        for (key, label, lim), ax in zip(observables, axes):
            for i, cmap in (0, 'Blues'), (4, 'Oranges'):
                x = cal['validation'][key]['Y'][:, i]
                xerr = cal['validation'][key]['Yerr'][:, i]
                y = vld[key]['Y'][:, i]
                yerr = vld[key]['Yerr'][:, i]
                ax.errorbar(
                    x, y, xerr=xerr, yerr=yerr, fmt='o', capsize=0,
                    color=getattr(plt.cm, cmap)(.8), mec='white', mew=.25,
                    label='–'.join(map(str, cent_bins[i])) + '%'
                )
            ax.plot(lim, lim, lw=1, color='.7', zorder=-10)
            ax.set_xlim(lim)
            ax.set_ylim(lim)
            ax.set_aspect('equal')
            ax.set_xlabel('Predicted ' + label)
            if ax.is_first_col():
                ax.set_ylabel('Observed')
                ax.legend(loc='best', handletextpad=0)
            set_loc(ax)

    finish(pad=0.7)


@plot
def gp(**kwargs):
    np.random.seed(321478)
    plt.rc('axes', prop_cycle=plt.cycler(
        color=plt.cm.Set2(np.linspace(0, 1, 8)).tolist()
    ))

    fig, axes = plt.subplots(nrows=2, sharex='col',
                             figsize=(.45*textwidth, .85*textheight))

    t = np.linspace(0, 5, 1000)
    x = np.linspace(.5, 4.5, 4)
    gp = george.GP(
        george.kernels.ExpSquaredKernel(1.) +
        george.kernels.WhiteKernel(1e-8)
    )
    gp.compute(x)
    y = gp.sample()
    y -= .5*(y.max() + y.min())

    mean_kw = dict(color='.42', dashes=(3.5, 1.5))
    err_kw = dict(color='.9')

    ax = axes[0]
    ax.axhspan(-2, 2, **err_kw)
    ax.axhline(0, **mean_kw)
    for s in gp.sample(t, size=4):
        ax.plot(t, s)

    ax = axes[1]
    mu, cov = gp.predict(y, t)
    std = np.sqrt(cov.diagonal())
    ax.fill_between(t, mu+2*std, mu-2*std, **err_kw)
    ax.plot(t, mu, **mean_kw)
    for s in gp.sample_conditional(y, t, size=3):
        ax.plot(t, s)
    ax.plot(x, y, 'o', ms=3, color=offblack)

    ax.set_xlabel('Input')

    ax.annotate(
        '\n'.join([
            'Dashed line: mean',
            'Band: 2$\\sigma$ uncertainty',
            'Colored lines: sampled functions'
        ]), (.03, .03), xycoords='axes fraction',
        ha='left', va='bottom')

    titles = ['Random functions',
              'Conditioned on training data (dots)']

    for ax, title in zip(axes, titles):
        ax.annotate(title, (.5, .995), xycoords='axes fraction',
                    ha='center', va='top')

    for ax in axes:
        ax.set_ylabel('Output')
        ax.set_xlim(0, 5)
        ax.set_ylim(-2.5, 2.5)

    finish(pad=.2, h_pad=1)


@plot
def trento_events(**kwargs):
    fig, axes = plt.subplots(
        nrows=3, sharex='col',
        figsize=(.3*textwidth, .88*textheight)
    )

    xymax = 8.
    xyr = [-xymax, xymax]

    with tempfile.NamedTemporaryFile(suffix='.hdf') as t:
        subprocess.check_call((
            'trento Pb Pb {} --quiet --b-max 12 '
            '--grid-max {} --grid-step .1 '
            '--random-seed 23415879 --output {}'
        ).format(axes.size, xymax, t.name).split())

        with h5py.File(t.name, 'r') as f:
            for dset, ax in zip(f.values(), axes):
                ax.pcolorfast(xyr, xyr, np.array(dset), cmap=plt.cm.Blues)
                ax.set_aspect('equal')
                for xy in ['x', 'y']:
                    getattr(ax, 'set_{}ticks'.format(xy))([-5, 0, 5])

    axes[-1].set_xlabel('$x$ [fm]')
    axes[1].set_ylabel('$y$ [fm]')

    finish(pad=0, h_pad=.5)


def main():
    parser = argparse.ArgumentParser()

    parser.add_argument('--design', default='../data/model/design.hdf')
    parser.add_argument('--calibration', default='../calibration/results.hdf')
    parser.add_argument('--calibration-nch',
                        default='../calibration/results-nch.hdf')
    parser.add_argument('--exp-data', default='../data/exp/data.hdf')

    for suffix in ['', '-mode', '-mode-nch', '-validation']:
        parser.add_argument(
            '--batch-obs' + suffix,
            default='../data/model/batch-observables{}.hdf'.format(suffix)
        )

    parser.add_argument('plots', nargs='*')

    args = parser.parse_args()

    if args.plots:
        for i in args.plots:
            if i.endswith('.pdf'):
                i = i[:-4]
            if i in plot_functions:
                plot_functions[i](**vars(args))
            else:
                print('unknown plot:', i)
    else:
        for f in plot_functions.values():
            f(**vars(args))


if __name__ == "__main__":
    main()
