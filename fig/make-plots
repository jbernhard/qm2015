#!/usr/bin/env python3

import argparse

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.ticker as tick
import h5py


fontsmall, fontnormal = 18, 22
offblack = '#262626'

plt.rcdefaults()
plt.rcParams.update({
    'font.family': 'sans-serif',
    'font.sans-serif': ['Lato'],
    'mathtext.fontset': 'custom',
    'mathtext.default': 'it',
    'mathtext.rm': 'sans',
    'mathtext.it': 'sans:italic',
    'mathtext.cal': 'sans',
    'font.size': fontnormal,
    'legend.fontsize': fontnormal,
    'axes.labelsize': fontnormal,
    'axes.titlesize': fontnormal,
    'xtick.labelsize': fontsmall,
    'ytick.labelsize': fontsmall,
    'font.weight': 300,
    'axes.labelweight': 300,
    'axes.titleweight': 300,
    'lines.linewidth': 1.5,
    'lines.markeredgewidth': 0,
    'patch.linewidth': 1.5,
    'axes.linewidth': 1,
    'xtick.major.width': 1,
    'ytick.major.width': 1,
    'xtick.minor.width': 1,
    'ytick.minor.width': 1,
    'xtick.major.size': 5,
    'ytick.major.size': 5,
    'xtick.minor.size': 3,
    'ytick.minor.size': 3,
    'xtick.major.pad': 8,
    'ytick.major.pad': 8,
    'text.color': offblack,
    'axes.edgecolor': offblack,
    'axes.labelcolor': offblack,
    'xtick.color': offblack,
    'ytick.color': offblack,
    'legend.numpoints': 1,
    'legend.scatterpoints': 1,
    'legend.frameon': False,
    'image.interpolation': 'none',
    'pdf.fonttype': 42
})


plot_functions = {}


def plot(f):
    def wrapper(*args, **kwargs):
        print(f.__name__)
        f(*args, **kwargs)
        plt.savefig('{}.pdf'.format(f.__name__))
        plt.close()

    plot_functions[f.__name__] = wrapper

    return wrapper


def finish(despine=True, remove_ticks=False, pad=0.1, h_pad=None, w_pad=None):
    fig = plt.gcf()

    for ax in fig.axes:
        if despine:
            for spine in 'top', 'right':
                ax.spines[spine].set_visible(False)

        if remove_ticks:
            for ax_name in 'xaxis', 'yaxis':
                getattr(ax, ax_name).set_ticks_position('none')
        else:
            ax.xaxis.set_ticks_position('bottom')
            ax.yaxis.set_ticks_position('left')

    fig.tight_layout(pad=pad, h_pad=h_pad, w_pad=w_pad)


def set_loc(ax, xy=None, nbins=5, steps=(1, 2, 3, 4, 10), prune=None):
    if xy == 'x':
        axes = ax.xaxis,
    elif xy == 'y':
        axes = ax.yaxis,
    else:
        axes = ax.xaxis, ax.yaxis

    for axis in axes:
        axis.set_major_locator(
            tick.MaxNLocator(nbins=nbins, steps=steps, prune=prune)
        )


@plot
def posterior(design, calibration, **kwargs):
    with h5py.File(design, 'r') as f:
        labels = list(f['parameters'])
        ranges = np.array(f['range'])

    with h5py.File(calibration, 'r') as f:
        chain = np.array(f['chain']).T

    nxy = chain.shape[0]
    assert nxy == len(labels)

    normal_cmap, highlight_cmap = plt.cm.Blues, plt.cm.Oranges

    fig, axes = plt.subplots(
        nrows=nxy, ncols=nxy,
        sharex='col', sharey='row',
        figsize=(22, 22)
    )

    for n, (ax, x, (xmin, xmax)) in enumerate(
            zip(axes.diagonal(), chain, ranges)):
        cmap = highlight_cmap if n in [1, 7, 8] else normal_cmap
        line_color = cmap(.8)
        fill_color = cmap(.5, alpha=.1)

        counts, edges = np.histogram(
            x, bins=64, range=(xmin, xmax), density=True
        )
        middles = .5 * (edges[1:] + edges[:-1])
        counts *= .9 * (xmax - xmin) / counts.max()
        counts += xmin
        ax.plot(middles, counts, lw=2, color=line_color)
        ax.fill_between(middles, xmin, counts, color=fill_color)
        ax.set_xlim(xmin, xmax)
        ax.set_ylim(xmin, xmax)

    for ny, nx in zip(*np.tril_indices_from(axes, k=-1)):
        H, xedges, yedges = np.histogram2d(
            chain[nx], chain[ny], bins=64, range=(ranges[nx], ranges[ny])
        )
        H[H == 0] = None
        cmap = highlight_cmap if (ny, nx) == (6, 5) else normal_cmap
        axes[ny][nx].pcolorfast(xedges, yedges, H.T, cmap=cmap)

        axes[nx][ny].set_axis_off()

    for ax in axes.flat:
        set_loc(ax, nbins=4)

    for n, label in enumerate(labels):
        axes[-1][n].set_xlabel(label)
        axes[n][0].set_ylabel(label)

    finish()


@plot
def observables_samples(calibration, exp_data, **kwargs):
    id_parts = [
        ('pion',   r'$\pi^\pm$', 'Blues'),
        ('kaon',   r'$K^\pm$', 'Greens'),
        ('proton', r'$p\bar p$', 'Reds')
    ]

    flows = [(str(n), '$v_{}$'.format(n), c)
             for n, c in enumerate(['GnBu', 'Purples', 'Oranges'], start=2)]

    plots = [
        ('dN_dy', 'Identified particle yields', r'$dN/dy$', (1, 3e3),
         id_parts),
        ('mean_pT', 'Identified particle mean $p_T$',
         r'$p_T$ [GeV]', (0, 1.5), id_parts),
        ('vn', 'Flow cumulants', r'$v_n\{2\}$', (0, 0.11), flows),
    ]

    fig, axes = plt.subplots(nrows=len(plots), figsize=(9, 16))

    with \
            h5py.File(calibration, 'r') as cal, \
            h5py.File(exp_data, 'r') as exp:
        sample_idx = np.random.randint(0, cal['chain'].shape[0], size=100)

        for ax, (obs, title, ylabel, ylim, subplots) in zip(axes, plots):
            for subobs, label, cmap in subplots:
                color = getattr(plt.cm, cmap)(0.6)

                samples_dset = cal['samples'][obs][subobs]
                x, y, yerr = (exp[obs][subobs][k][:samples_dset.shape[1]]
                              for k in ['x', 'y', 'yerr'])

                for i in sample_idx:
                    ax.plot(x, samples_dset[i],
                            color=color, alpha=0.2, lw=0.5)

                ax.errorbar(x, y, yerr=yerr, fmt='o',
                            capsize=0, color='0.2', zorder=1000)

                ax.text(x[-1] + 2, y[-1], label, ha='left', va='center',
                        size=fontnormal)

            ax.set_xlim(0, 70)
            ax.set_ylim(ylim)
            ax.set_ylabel(ylabel, labelpad=10)
            ax.set_title(title)

            if obs == 'dN_dy':
                ax.set_yscale('log')
                ax.minorticks_off()
            else:
                set_loc(ax, 'y', nbins=6)

    axes[-1].set_xlabel('Centrality %', labelpad=10)

    finish(h_pad=1)


def _zetas(T, Tc=0.180,
           A1=-13.77, A2=27.55, A3=13.45,
           lam1=0.9, lam2=0.25, lam3=0.9, lam4=0.22,
           sig1=0.025, sig2=0.13, sig3=0.0025, sig4=0.022):
    t = np.asarray(T)/Tc
    zetas = np.empty_like(t)

    low = t < 0.995
    xm1 = t[low] - 1
    zetas[low] = lam3*np.exp(xm1/sig3) + lam4*np.exp(xm1/sig4) + 0.03

    high = t > 1.05
    xm1 = t[high] - 1
    zetas[high] = lam1*np.exp(-xm1/sig1) + lam2*np.exp(-xm1/sig2) + 0.001

    mid = ~(low | high)
    x = t[mid]
    zetas[mid] = A1*x*x + A2*x - A3

    return zetas


@plot
def viscosity_samples(calibration, **kwargs):
    fig, axes = plt.subplots(nrows=2, figsize=(9, 11))
    etas_ax, zetas_ax = axes

    Tmin, Tc, Tmax = 0.145, 0.154, 0.300
    T1 = np.linspace(Tmin, Tmax, 1000)
    T2 = np.linspace(Tc, Tmax, 100)
    kwargs = dict(color=plt.cm.Blues(0.7), alpha=0.2, lw=0.7)

    with h5py.File(calibration, 'r') as cal:
        sample_idx = np.random.randint(0, cal['chain'].shape[0], size=200)

        for i in sample_idx:
            etas_min, etas_slope, zetas_norm = cal['chain'][i, 5:8]
            etas_ax.plot(T2, etas_min + etas_slope*(T2 - Tc), **kwargs)
            zetas_ax.plot(T1, zetas_norm*_zetas(T1), **kwargs)

    text_color = '0.35'
    fill_kwargs = dict(color='0.9', zorder=-1000)

    etas_ax.fill_between(T2, 0.3 + 2*(T2 - Tc), **fill_kwargs)
    etas_ax.axvline(Tc, ls='dashed', lw=1, color=text_color)
    etas_ax.text(Tc + 0.003, 0.5, '$T_c = {}$ GeV'.format(Tc),
                 ha='left', va='center', color=text_color)
    etas_ax.text(0.21, 0.42, 'initial range', color=text_color, rotation=17)
    etas_ax.text(
        0.296, 0.04,
        '$(\eta/s)(T) = '
        '(\eta/s)_\mathrm{min} + (\eta/s)_\mathrm{slope}(T - T_c)$',
        ha='right', color=text_color
    )
    etas_ax.set_ylabel(r'$\eta/s$', labelpad=10)

    zetas_ax.plot(T1, _zetas(T1), color=offblack, lw=2)
    zetas_ax.fill_between(T1, 2*_zetas(T1), **fill_kwargs)
    zetas_ax.text(0.193, 0.52, 'initial range', color=text_color)
    zetas_ax.text(
        0.21, 0.40,
        '$(\zeta/s)(T)$ parametrization from [?]\n'
        'vary overall normalization 0â€“2\n'
        'black line: norm = 1',
        va='top', color=text_color
    )
    zetas_ax.set_xlabel('Temperature [GeV]', labelpad=10)
    zetas_ax.set_ylabel(r'$\zeta/s$', labelpad=10)

    for ax in axes:
        ax.set_xticks(np.arange(150, 301, 50)/1000)
        ax.set_xlim(Tmin, Tmax)

    finish(h_pad=1)


def main():
    parser = argparse.ArgumentParser()

    parser.add_argument('--design', default='../data/model/design.hdf')
    parser.add_argument('--calibration', default='../calibration/results.hdf')
    parser.add_argument('--exp-data', default='../data/exp/data.hdf')

    parser.add_argument('plots', nargs='*')

    args = parser.parse_args()

    if args.plots:
        for i in args.plots:
            if i.endswith('.pdf'):
                i = i[:-4]
            try:
                plot_functions[i](**vars(args))
            except KeyError:
                print('unknown plot:', i)
    else:
        for f in plot_functions.values():
            f(**vars(args))


if __name__ == "__main__":
    main()
